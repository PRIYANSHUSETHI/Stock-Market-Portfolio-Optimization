# -*- coding: utf-8 -*-
"""stock mkt portfolio optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QwDGBs8x3gQtyRrcaFUanpSNAS2E8d1i
"""

from datetime import datetime, timedelta
import pandas as pd
import yfinance as yf

# Define the time period for the data
end_date = datetime.today().strftime("%Y-%m-%d")
start_date = (datetime.today() - timedelta(days=365)).strftime("%Y-%m-%d")

# List of stock tickers to download
tickers = ['RELIANCE.NS', 'TCS.NS', 'INFY.NS', 'HDFCBANK.NS']

# Download data
data = yf.download(tickers, start=start_date, end=end_date, progress=False)

# Ensure 'Date' is a column
data.index.name = 'Date'  # Set the index name so it becomes a column on reset
data = data.reset_index()

# Flatten the MultiIndex column names
data.columns = ['Date' if col[0] == 'Date' else f'{col[1]}_{col[0]}' for col in data.columns.to_flat_index()]

# Melt the DataFrame
data_melted = data.melt(id_vars='Date', var_name='Ticker_Attribute', value_name='Value')

# Split into Ticker and Attribute
data_melted[['Ticker', 'Attribute']] = data_melted['Ticker_Attribute'].str.rsplit('_', n=1, expand=True)

# Pivot to get attributes as columns
data_pivoted = data_melted.pivot_table(index=['Date', 'Ticker'], columns='Attribute', values='Value', aggfunc='first')

# Reset index
stock_data = data_pivoted.reset_index()

# Output
print(stock_data.head())

import matplotlib.pyplot as plt
import seaborn as sns

# Convert to datetime if not already
stock_data['Date'] = pd.to_datetime(stock_data['Date'])

# Reset index just in case
stock_data.reset_index(inplace=True, drop=True)

# Plot
plt.figure(figsize=(14, 7))
sns.set(style='whitegrid')

sns.lineplot(data=stock_data, x='Date', y='Close', hue='Ticker', marker='o')

plt.title('Close Price Over Time', fontsize=16)
plt.xlabel('Date', fontsize=14)
plt.ylabel('Close Price', fontsize=14)
plt.legend(title='Ticker', title_fontsize='13', fontsize='11')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()

plt.show()

short_window = 50
long_window = 200

# Reset and set index safely
stock_data.reset_index(inplace=True)
stock_data.set_index('Date', inplace=True)

unique_tickers = stock_data['Ticker'].unique()

for ticker in unique_tickers:
    ticker_data = stock_data[stock_data['Ticker'] == ticker].copy()
    ticker_data['50_MA'] = ticker_data['Close'].rolling(window=short_window).mean()
    ticker_data['200_MA'] = ticker_data['Close'].rolling(window=long_window).mean()

    plt.figure(figsize=(14, 7))
    plt.plot(ticker_data.index, ticker_data['Close'], label='Close')
    plt.plot(ticker_data.index, ticker_data['50_MA'], label='50-Day MA')
    plt.plot(ticker_data.index, ticker_data['200_MA'], label='200-Day MA')
    plt.title(f'{ticker} - Close Price and Moving Averages')
    plt.xlabel('Date')
    plt.ylabel('Price')
    plt.legend()
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

    plt.figure(figsize=(14, 7))
    plt.bar(ticker_data.index, ticker_data['Volume'], label='Volume', color='orange')
    plt.title(f'{ticker} - Volume Traded')
    plt.xlabel('Date')
    plt.ylabel('Volume')
    plt.legend()
    plt.grid(True)
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Calculate daily returns using 'Close'
stock_data['Daily Return'] = stock_data.groupby('Ticker')['Close'].pct_change()

plt.figure(figsize=(14, 7))
sns.set(style='whitegrid')

# Plot histogram of returns per ticker
for ticker in unique_tickers:
    ticker_data = stock_data[stock_data['Ticker'] == ticker]
    sns.histplot(ticker_data['Daily Return'].dropna(), bins=50, kde=True, label=ticker, alpha=0.5)

plt.title('Distribution of Daily Returns', fontsize=16)
plt.xlabel('Daily Return', fontsize=14)
plt.ylabel('Frequency', fontsize=14)
plt.legend(title='Ticker', title_fontsize='13', fontsize='11')
plt.grid(True)
plt.tight_layout()
plt.show()

returns_summary = stock_data.groupby('Ticker')['Daily Return'].agg(['mean', 'std'])
plt.figure(figsize=(10, 6))
plt.scatter(returns_summary['std'], returns_summary['mean'], s=100)

for ticker in returns_summary.index:
    plt.text(returns_summary.loc[ticker, 'std'], returns_summary.loc[ticker, 'mean'], ticker)

plt.xlabel('Risk (Std Dev of Daily Returns)')
plt.ylabel('Expected Return (Mean of Daily Returns)')
plt.title('Risk vs Return')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib as mpl

# Optional: set the style and font
sns.set_theme(style="white", font_scale=1.2)
plt.rcParams['font.family'] = 'DejaVu Sans'  # Looks clean and modern

# Create the correlation matrix
stock_data.reset_index(inplace=True)
stock_data['Daily Return'] = stock_data.groupby('Ticker')['Close'].pct_change()
daily_returns = stock_data.pivot_table(index='Date', columns='Ticker', values='Daily Return')
correlation_matrix = daily_returns.corr()

# Create a custom color palette
cmap = sns.diverging_palette(220, 20, as_cmap=True)

# Create the plot
plt.figure(figsize=(12, 10))
ax = sns.heatmap(
    correlation_matrix,
    annot=True,
    cmap=cmap,
    center=0,
    fmt=".2f",
    linewidths=0.8,
    linecolor='lightgrey',
    cbar_kws={"shrink": 0.8, "aspect": 30},
    annot_kws={"size": 12, "weight": "bold"}
)

# Title and axis tweaks
plt.title('Correlation Matrix of Daily Returns', fontsize=18, pad=20, weight='bold')
plt.xticks(rotation=45, ha='right', fontsize=11)
plt.yticks(rotation=0, fontsize=11)
plt.tight_layout()

# Make plot background cleaner
sns.despine(left=True, bottom=True)

plt.show()

import numpy as np

expected_returns = daily_returns.mean() * 252  # annualize the returns
volatility = daily_returns.std() * np.sqrt(252)  # annualize the volatility

stock_stats = pd.DataFrame({
    'Expected Return': expected_returns,
    'Volatility': volatility
})

stock_stats

# function to calculate portfolio performance
def portfolio_performance(weights, returns, cov_matrix):
    portfolio_return = np.dot(weights, returns)
    portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    return portfolio_return, portfolio_volatility

# number of portfolios to simulate
num_portfolios = 10000

# arrays to store the results
results = np.zeros((3, num_portfolios))

# annualized covariance matrix
cov_matrix = daily_returns.cov() * 252

np.random.seed(42)

for i in range(num_portfolios):
    weights = np.random.random(len(unique_tickers))
    weights /= np.sum(weights)

    portfolio_return, portfolio_volatility = portfolio_performance(weights, expected_returns, cov_matrix)

    results[0,i] = portfolio_return
    results[1,i] = portfolio_volatility
    results[2,i] = portfolio_return / portfolio_volatility  # Sharpe Ratio

plt.figure(figsize=(10, 7))
plt.scatter(results[1,:], results[0,:], c=results[2,:], cmap='YlGnBu', marker='o')
plt.title('Efficient Frontier')
plt.xlabel('Volatility (Standard Deviation)')
plt.ylabel('Expected Return')
plt.colorbar(label='Sharpe Ratio')
plt.grid(True)
plt.show()

max_sharpe_idx = np.argmax(results[2])
max_sharpe_return = results[0, max_sharpe_idx]
max_sharpe_volatility = results[1, max_sharpe_idx]
max_sharpe_ratio = results[2, max_sharpe_idx]

max_sharpe_return, max_sharpe_volatility, max_sharpe_ratio

max_sharpe_weights = np.zeros(len(unique_tickers))

for i in range(num_portfolios):
    weights = np.random.random(len(unique_tickers))
    weights /= np.sum(weights)

    portfolio_return, portfolio_volatility = portfolio_performance(weights, expected_returns, cov_matrix)

    if results[2, i] == max_sharpe_ratio:
        max_sharpe_weights = weights
        break

portfolio_weights_df = pd.DataFrame({
    'Ticker': unique_tickers,
    'Weight': max_sharpe_weights
})

portfolio_weights_df

